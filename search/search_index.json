{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Brillouin Analyzer Documentation","text":"<p>This project provides a lightweight toolkit for parsing, fitting, plotting, and segmenting Brillouin/Raman datasets. Use the docs below as a quick reference for the main modules.</p>"},{"location":"#outline","title":"Outline","text":"<ul> <li>Parsing: Load Brillouin and Raman datasets, including ZIP handling and lateral step detection.</li> <li>Manual Analysis: Fit peaks in a single spectrum or an entire volume with reproducible window and filtering controls.</li> <li>Plotting: Preview raw spectra, render spatial heatmaps, and summarize cell-level statistics.</li> <li>Cell Selection: Build RGB maps of shifts/FWHM, detect contours, and export per-region metrics.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>1) Parse data with <code>parse_brillouin_set</code> (or <code>parse_raman_set</code> for Raman). 2) Tune peak windows on one pixel using <code>analyze_brillouin_spectrum_manual</code>. 3) Run <code>analyze_brillouin_spectra_manual</code> over the full slice/volume. 4) Visualize with <code>plot_brillouin_heatmap</code> and segment regions with <code>detect_cells</code>. 5) Summarize groups using <code>plot_cell_boxplot</code> or <code>plot_cell_histogram</code>.</p>"},{"location":"#project-structure","title":"Project Structure","text":"<ul> <li><code>brillouin_parser.py</code>: Parsing helpers for Brillouin/Raman datasets.</li> <li><code>brillouin_spectra_analyzer_manual.py</code>: Peak finding, Lorentzian fitting, and batch processing.</li> <li><code>brillouin_plotter.py</code>: Spectrum previews, heatmaps, and statistical plots.</li> <li><code>brillouin_cell_selector.py</code>: Cell/background detection and CSV export.</li> </ul>"},{"location":"cell_selection/","title":"Cell Selection Module","text":"<p>The <code>brillouin_cell_selector.detect_cells</code> helper turns a peaks map into an RGB heatmap (Stokes shift = red, FWHM = green, Anti-Stokes shift = blue) and extracts per-cell masks. Use it after running the manual analyzer and before aggregating statistics with the plotting functions.</p>"},{"location":"cell_selection/#what-goes-in","title":"What goes in","text":"<ul> <li><code>peaks_map</code>: a <code>BrillouinPeaksMap</code> or list of maps from <code>analyze_brillouin_spectra_manual</code>. Lists are aggregated per pixel with <code>pixel_aggregation</code> (<code>mean</code> or <code>median</code>).</li> <li>Spatial scaling: set <code>scaling_factor='auto'</code> to reuse the lateral step stored with the peaks map or pass a numeric micron-per-pixel value.</li> </ul>"},{"location":"cell_selection/#pre-processing-controls","title":"Pre-processing controls","text":"<ul> <li>Filtering: choose <code>filter_type</code> (<code>median</code>, <code>gaussian</code>, <code>bilateral</code>, <code>wiener</code>, <code>anisotropic_diffusion</code>, <code>total_variation</code>, <code>non_local_means</code>) with <code>filter_params</code>. Set <code>interpolate_nan=True</code> to fill gaps first.</li> <li>Normalization and ranges: <code>normalize</code> scales channels to [0, 1]; <code>shift_range</code>/<code>fwhm_range</code> clip values (use <code>'auto'</code> or <code>('auto', p_low, p_high)</code> for percentile clipping).</li> <li>Aggregation inside each peak: <code>aggregation</code> (<code>median</code>, <code>mean</code>, or <code>robust</code>) controls how per-pixel values are extracted.</li> </ul>"},{"location":"cell_selection/#how-cells-are-detected","title":"How cells are detected","text":"<ul> <li>Thresholding: pick <code>threshold_method</code> (<code>otsu</code>, <code>adaptive</code>, <code>fixed</code>, or <code>manual</code>). For manual mode, pass <code>manual_regions</code> with polygons or circles. <code>threshold_value</code> is required when <code>fixed</code>.</li> <li>Post-processing: <code>pre_gaussian_blur</code> smooths the grayscale map before thresholding; <code>morph_op</code> applies open/close morphology; <code>contour_smoothing</code> simplifies contour polygons.</li> <li>Contour filters: <code>cell_area</code> limits pixel area, and <code>prominence</code> rejects dim regions. <code>mark_all=True</code> skips detection and treats the whole field as one cell.</li> </ul>"},{"location":"cell_selection/#outputs","title":"Outputs","text":"<pre><code>cell_shift_maps      # dict with keys 'stokes', 'anti-stokes', 'all' -&gt; list of arrays (one per cell)\ncell_fwhm_maps       # dict with keys 'stokes', 'anti-stokes', 'all' -&gt; list of arrays (one per cell)\nbackground_shift_maps  # same keys, arrays with cells masked out\nbackground_fwhm_maps   # same keys, arrays with cells masked out\n</code></pre> <p>If <code>save_csv</code> is a path, a CSV is written for every detected region (plus background when available) with median shift and FWHM. Use <code>fig_path</code> and <code>save_fig=True</code> to store the plotted RGB map with contours and numbering; <code>annotate=True</code> adds per-region statistics to the figure.</p>"},{"location":"cell_selection/#example","title":"Example","text":"<pre><code>from brillouin_analyzer_src.brillouin_cell_selector import detect_cells\n\ncell_shift_maps, cell_fwhm_maps, bg_shift, bg_fwhm = detect_cells(\n    peaks_map=peaks_maps[0],\n    title=\"Cell map\",\n    shift_range=\"auto\",\n    fwhm_range=\"auto\",\n    filter_type=\"gaussian\",\n    filter_params={\"sigma\": 1.2},\n    threshold_method=\"otsu\",\n    cell_area=[50, 5000],\n    annotate=True,\n    save_fig=True,\n    fig_path=\"exports/cell_map.png\",\n    save_csv=\"exports/cell_stats\"\n)\n</code></pre>"},{"location":"manual_analysis/","title":"Manual Analysis Module","text":"<p>The <code>brillouin_spectra_analyzer_manual</code> module lets you inspect a single spectrum to tune peak-finding parameters and then run the same settings over an entire 3D dataset. Use it right after parsing data with <code>parse_brillouin_set</code>.</p>"},{"location":"manual_analysis/#typical-workflow","title":"Typical Workflow","text":"<p>1) Parse spectra into a 3D array. 2) Call <code>analyze_brillouin_spectrum_manual</code> on a single pixel to pick laser/Brillouin windows and fitting options. 3) Reuse those parameters in <code>analyze_brillouin_spectra_manual</code> for a full slice or volume. 4) Visualize and segment the results with the plotting and cell-selection utilities.</p>"},{"location":"manual_analysis/#single-spectrum-analyze_brillouin_spectrum_manual","title":"Single spectrum: <code>analyze_brillouin_spectrum_manual</code>","text":"<p>Analyzes one spectrum from the cube (or a provided <code>spectrum_data</code>) and optionally plots the fit.</p> <p>Key arguments - Coordinates: <code>x_coord</code>, <code>y_coord</code>, <code>z_coord</code> select the pixel; omit to inspect a random spectrum. <code>spectrum_cut_range</code> trims the waveform before processing. - Spectral geometry: <code>free_spectral_range</code> fits the quadratic VIPA calibration. Windows for peaks come from <code>laser_peak_ranges</code> (index windows or exact indices) and <code>brillouin_peak_ranges</code> (pairs of index windows or a tuple <code>(a_GHz, b_GHz)</code> around each laser). - Fitting: set <code>fit_lorentzians&gt;0</code> to fit Lorentzian peaks inside a \u00b1window (GHz). Control bounds via <code>fwhm_bounds_GHz</code> and <code>center_slack_GHz</code>. <code>match_brilouin_parameters=True</code> locks all left/right Brillouin peaks to shared width/shift. - Filtering and weighting: provide <code>filter_settings</code> (Savgol, wavelet, Fourier, PCA, or custom callables) to denoise before peak finding; enable <code>baseline_spectra</code> or <code>poisson_weighting</code> if you need them. - Debugging and plots: <code>debug_plot</code> overlays search windows, <code>plot_PCA</code>/<code>pca_*</code> help to locate laser peaks, <code>make_plot</code> controls size, and <code>save_plot</code> writes the figure.</p> <p>Outputs</p> <p>Returns a dictionary containing: - <code>df</code>: per-peak rows with type, shift, FWHM, center/amplitude, and fit RMSE. - <code>spectrum</code>, <code>rescaled_x_axis</code>, and the detected <code>laser_peaks_indices</code> / <code>brillouin_peaks_indices</code>. - <code>fit_params</code> <code>(a, b, c)</code> from the VIPA calibration plus lists of per-peak shifts, FWHMs, amplitudes, and centers. - Flags showing which options were enabled (baseline, weighting, matching, etc.).</p> <p>Example:</p> <pre><code>from brillouin_analyzer_src import *\n%load_ext autoreload\n%autoreload 2\n\nres = def analyze_brillouin_spectrum_manual(\n    brillouin_spectra,\n    x_coord=None,\n    y_coord=None,\n    z_coord=None,\n    free_spectral_range=29.98,\n    laser_peak_ranges=[626, 986, 1269, 1510],\n    brillouin_peak_ranges=(6, 11),\n    spectrum_cut_range=(350, 1600),\n    make_plot=(12, 8),\n    debug_plot=False,\n    # Lorentzian half-window in GHz (0 -&gt; disable fitting)\n    fit_lorentzians=1.5,\n\n    # Optional filter pipeline configuration\n    filter_settings=[{'type': 'savgol', 'params': (15, 6)},\n    {'type': 'wavelet', 'wavelet': 'db6', 'level': 5},\n    {'type': 'fft', 'params': (20, 100)}],\n    save_plot=False,\n\n    # Optional constraints for Lorentzian fitting (GHz)\n    fwhm_bounds_GHz=(0.8, 4.0),     # (min_fwhm, max_fwhm) or None\n    center_slack_GHz=0.5,    # \u00b1 slack around nominal center; if None, window-bound\n    spectrum_data=None,\n    baseline_spectra=False,\n    poisson_weighting=False,\n    match_brilouin_parameters=True,\n    ignore_brilouin_peaks=False,\n    plot_PCA=False,\n    pca_n_components=2,\n    pca_params={\n        'svd_solver': 'full',\n        'whiten': True,\n        'tol': 0.0,\n        'iterated_power': 5,\n        'random_state': None,\n        'copy': True,\n        },\n    pca_peak_finding_params={\n        'height': 0.02,  # Minimum height of peaks\n        'distance': 100,  # Minimum horizontal distance between peaks\n        'prominence': 0, # Minimum prominence of peaks\n        'width': 2, # Minimum width of peaks\n    }\n)\n</code></pre>"},{"location":"manual_analysis/#batch-mode-analyze_brillouin_spectra_manual","title":"Batch mode: <code>analyze_brillouin_spectra_manual</code>","text":"<p>Runs the same analysis across a z-slice or the full volume.</p> <p>Highlights - <code>z_coord=None</code> processes all slices; set an int to restrict to one slice. - Parallel execution via <code>max_workers</code> and <code>parallel_backend</code> (<code>auto</code>, <code>thread</code>, <code>process</code>). Use <code>max_workers=1</code> for reproducible sequential runs. - <code>laser_refit=True</code> performs a laser-only pre-pass to lock Rayleigh peak positions before full fitting. <code>refit</code> keeps a global VIPA refit (ignored when <code>laser_refit=True</code>). - Pass through the same peak windows, fitting, filtering, and matching options you validated on a single spectrum. <code>keep_waveforms=False</code> drops raw spectra from the results to save memory.</p> <p>Returns</p> <ul> <li>A <code>BrillouinPeaksMap</code> (or list of maps if <code>z_coord=None</code>) keyed by <code>(x, y, z)</code> with the per-pixel result dictionaries. The lateral step is stored internally for plotting and cell selection.</li> </ul> <p>Example:</p> <pre><code>from brillouin_analyzer_src import *\n%load_ext autoreload\n%autoreload 2\n\npeaks_maps = analyze_brillouin_spectra_manual(\n    data,\n    z_coord=None,\n    free_spectral_range=29.98,\n    laser_peak_ranges=[626, 986, 1269, 1510],\n    brillouin_peak_ranges=(6, 11),\n    spectrum_cut_range=(350, 1600),\n    fit_lorentzians=1.5,\n    filter_settings=[{'type': 'savgol', 'params': (15, 6)},\n    {'type': 'wavelet', 'wavelet': 'db6', 'level': 5},\n    {'type': 'fft', 'params': (20, 100)}],\n    refit=False,\n    laser_refit=True,\n    match_brilouin_parameters=True,\n    max_workers=8,\n    parallel_backend='auto'\n    keep_waveforms=False,\n    baseline_spectra=False,\n    poisson_weighting=False,\n    plot_PCA=False,\n    pca_n_components=2,\n    pca_params={\n        'svd_solver': 'full',\n        'whiten': True,\n        'tol': 0.0,\n        'iterated_power': 5,\n        'random_state': None,\n        'copy': True,\n        },\n    pca_peak_finding_params={\n        'height': 0.02,  # Minimum height of peaks\n        'distance': 100,  # Minimum horizontal distance between peaks\n        'prominence': 0, # Minimum prominence of peaks\n        'width': 2, # Minimum width of peaks\n    }\n)\n</code></pre>"},{"location":"parsing/","title":"Parsing Module","text":"<p>The <code>brillouin_parser</code> module provides functionality to load and parse Brillouin and Raman spectra data from directories or ZIP archives.</p>"},{"location":"parsing/#functions","title":"Functions","text":""},{"location":"parsing/#parse_brillouin_set","title":"<code>parse_brillouin_set</code>","text":"<pre><code>def parse_brillouin_set(directory_path, file_label):\n    ...\n</code></pre> <p>Parses a set of Brillouin spectra files.</p> <p>Arguments:</p> <ul> <li><code>directory_path</code> (str): Path to the directory or ZIP file containing the data.</li> <li><code>file_label</code> (str): The label used to identify the files (e.g., the prefix of the filenames).</li> </ul> <p>Returns:</p> <ul> <li><code>numpy.ndarray</code>: A 3D array of object type, where each element contains the spectral data (intensity) for a specific (x, y, z) coordinate. The indices of the array correspond to the spatial coordinates.</li> </ul> <p>Description:</p> <p>This function locates the dataset (extracting it from a ZIP file if necessary), finds the lateral step size, and reads <code>.asc</code> files matching the pattern <code>{file_label}B*_Z...Y...X...asc</code>. It constructs a 3D array representing the spatial distribution of the spectra.</p> <p>It also registers the lateral step metadata using <code>data_registry.register_lateral_step</code>.</p>"},{"location":"parsing/#parse_raman_set","title":"<code>parse_raman_set</code>","text":"<pre><code>def parse_raman_set(directory_path, file_label):\n    ...\n</code></pre> <p>Parses a set of Raman spectra files.</p> <p>Arguments:</p> <ul> <li><code>directory_path</code> (str): Path to the directory or ZIP file containing the data.</li> <li><code>file_label</code> (str): The label used to identify the files.</li> </ul> <p>Returns:</p> <ul> <li><code>dict</code> or <code>None</code>: A dictionary where keys are <code>(x, y, z)</code> tuples and values are the spectral data (intensity), or <code>None</code> if no files are found. (Note: The current implementation returns a dictionary, unlike <code>parse_brillouin_set</code> which returns a 3D array. Check implementation details if this is intended behavior).</li> </ul> <p>Description:</p> <p>Similar to <code>parse_brillouin_set</code>, this function reads <code>.asc</code> files matching the pattern <code>{file_label}R*_Z...Y...X...asc</code>.</p>"},{"location":"parsing/#file-naming-convention","title":"File Naming Convention","text":"<p>The parser expects files to follow a specific naming convention to extract spatial coordinates:</p> <ul> <li>Brillouin files: <code>{file_label}B*_Z{z}Y{y}X{x}.asc</code></li> <li>Raman files: <code>{file_label}R*_Z{z}Y{y}X{x}.asc</code></li> </ul> <p>Where <code>{x}</code>, <code>{y}</code>, and <code>{z}</code> are integer coordinates.</p>"},{"location":"parsing/#lateral-step-detection","title":"Lateral Step Detection","text":"<p>The parser attempts to automatically detect the \"Lateral step\" size from text files in the directory. It looks for files named: 1.  <code>{file_label}.txt</code> 2.  <code>{sanitized_label}.txt</code> (spaces replaced by underscores) 3.  <code>file_label.txt</code></p> <p>It searches for a line matching the pattern <code>Lateral step : {value}</code>.</p>"},{"location":"parsing/#zip-archive-support","title":"ZIP Archive Support","text":"<p>The functions support reading data directly from ZIP archives. If <code>directory_path</code> points to a <code>.zip</code> file, the parser will: 1.  Extract the archive to a temporary directory. 2.  Search for a folder matching <code>file_label</code> or its sanitized version. 3.  If not found, check if there is a single top-level directory. 4.  If not found, search for a directory containing files starting with <code>file_label</code>. 5.  Use the found directory as the source for parsing.</p>"},{"location":"plotting/","title":"Plotting Module","text":"<p>The <code>brillouin_plotter</code> utilities turn parsed/analysed data into figures for validation and publication. They accept the outputs of <code>parse_brillouin_set</code>, <code>analyze_brillouin_spectrum_manual</code>, and <code>analyze_brillouin_spectra_manual</code>, plus the cell masks produced by <code>detect_cells</code>.</p>"},{"location":"plotting/#spectra-preview-plot_raw_spectrum","title":"Spectra preview: <code>plot_raw_spectrum</code>","text":"<p>Plots a single raw spectrum and marks peaks found by <code>scipy.signal.find_peaks</code>. - <code>spectrum_range</code> trims the waveform before plotting; negative values are clamped to zero automatically. - <code>height</code>, <code>distance</code>, and <code>prominence</code> are passed to <code>find_peaks</code>. - <code>mark_ranges</code> shades useful index ranges (for example, candidate laser windows).</p> <pre><code>from brillouin_analyzer_src.brillouin_plotter import plot_raw_spectrum\nplot_raw_spectrum(spectra, x_coord=3, y_coord=4, z_coord=0, mark_ranges=[(200, 260)])\n</code></pre>"},{"location":"plotting/#spatial-heatmaps-plot_brillouin_heatmap","title":"Spatial heatmaps: <code>plot_brillouin_heatmap</code>","text":"<p>Builds a heatmap from a peaks map (or a list of maps) returned by the manual analyzer. - Pick the value to plot with <code>data_type</code> (<code>Shift</code> or <code>FWHM</code>) and <code>peak_type</code> (<code>Brillouin</code>, <code>Brillouin Left</code>, <code>Brillouin Right</code>, <code>Laser</code>, etc.). <code>match_type='contains'</code> broadens label matching. - Aggregation: <code>aggregation</code> applies inside each pixel (median/mean/robust); <code>pixel_aggregation</code> combines multiple maps (mean/median). - Cleaning: <code>interpolate_nan</code>, optional filters (<code>median</code>, <code>gaussian</code>, <code>bilateral</code>, <code>wiener</code>, <code>anisotropic_diffusion</code>, <code>total_variation</code>, <code>non_local_means</code>), and <code>colorbar_range</code> control visibility. - Axes: set <code>scale='auto'</code> to reuse the lateral step stored in the peaks map or pass a numeric scale. <code>matrix_save_path</code> writes the plotted matrix to a tab-separated file.</p> <pre><code>from brillouin_analyzer_src.brillouin_plotter import plot_brillouin_heatmap\nplot_brillouin_heatmap(\n    peaks_map=peaks_maps[0],\n    title=\"Median Brillouin shift\",\n    data_type=\"Shift\",\n    peak_type=\"Brillouin\",\n    pixel_aggregation=\"median\",\n    colorbar_range=\"auto\",\n    scale=\"auto\"\n)\n</code></pre>"},{"location":"plotting/#cell-level-statistics","title":"Cell-level statistics","text":"<p>Use the outputs of <code>detect_cells</code> (cell shift/FWHM maps plus background) to summarize samples.</p>"},{"location":"plotting/#boxviolinerror-plots-plot_cell_boxplot","title":"Box/violin/error plots: <code>plot_cell_boxplot</code>","text":"<ul> <li>Inputs: <code>samples_data_list</code> is a list where each element is the 4-tuple returned by <code>detect_cells</code> (shift maps, FWHM maps, background shift, background FWHM). Pass multiple samples to compare cohorts.</li> <li>Pick metric with <code>data_type</code> (<code>shift</code>/<code>fwhm</code>) and <code>shift_type</code> (<code>stokes</code>, <code>anti-stokes</code>, <code>all</code>).</li> <li>Presentation controls: <code>plot_type</code> (<code>box</code>, <code>violin</code>, <code>errorbar</code>, or <code>scatter</code>), <code>aggregate_per_cell</code> (<code>pixel</code>, <code>cell</code>, or <code>both</code>), <code>show_data_points</code>, and <code>plot_background</code>.</li> <li>Statistics: enable <code>plot_p_values</code> with <code>comparisons=[(0,1), ...]</code>, choose <code>test_type</code> (<code>mannwhitney</code>, <code>ttest</code>, or <code>both</code>), and format with <code>p_value_format</code> (<code>numeric</code> or <code>stars</code>).</li> </ul> <pre><code>from brillouin_analyzer_src.brillouin_plotter import plot_cell_boxplot\nplot_cell_boxplot(\n    samples_data_list=[cells_treated, cells_control],\n    labels=[\"Treated\", \"Control\"],\n    data_type=\"shift\",\n    shift_type=\"all\",\n    plot_type=\"box\",\n    plot_p_values=True,\n    comparisons=[(0, 1)]\n)\n</code></pre>"},{"location":"plotting/#histograms-plot_cell_histogram","title":"Histograms: <code>plot_cell_histogram</code>","text":"<p>Creates a histogram of per-cell or background values, fits a Gaussian, and can export the underlying arrays. - <code>data_list</code> accepts the same 4-tuples from <code>detect_cells</code>; set <code>cell_or_background</code> accordingly. - Limit with <code>cell_numbers</code>, clip with <code>value_range</code>, and choose <code>data_type</code>/<code>shift_type</code>. - Set <code>save_values=True</code> (optionally with <code>values_output_dir</code> and <code>values_filename_prefix</code>) to write both shift and FWHM arrays to disk.</p> <pre><code>from brillouin_analyzer_src.brillouin_plotter import plot_cell_histogram\nplot_cell_histogram(\n    [cells_treated],\n    title=\"Shift distribution\",\n    cell_or_background=\"cell\",\n    data_type=\"shift\",\n    shift_type=\"all\",\n    bin_number=20,\n    save_values=True,\n    values_output_dir=\"exports\"\n)\n</code></pre>"}]}