{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Brillouin Analyzer Documentation \u00b6 This project provides a lightweight toolkit for parsing, fitting, plotting, and segmenting Brillouin/Raman datasets. Use the docs below as a quick reference for the main modules. Outline \u00b6 Parsing : Load Brillouin and Raman datasets, including ZIP handling and lateral step detection. Manual Analysis : Fit peaks in a single spectrum or an entire volume with reproducible window and filtering controls. Plotting : Preview raw spectra, render spatial heatmaps, and summarize cell-level statistics. Cell Selection : Build RGB maps of shifts/FWHM, detect contours, and export per-region metrics. Quick Start \u00b6 1) Parse data with parse_brillouin_set (or parse_raman_set for Raman). 2) Tune peak windows on one pixel using analyze_brillouin_spectrum_manual . 3) Run analyze_brillouin_spectra_manual over the full slice/volume. 4) Visualize with plot_brillouin_heatmap and segment regions with detect_cells . 5) Summarize groups using plot_cell_boxplot or plot_cell_histogram . Project Structure \u00b6 brillouin_parser.py : Parsing helpers for Brillouin/Raman datasets. brillouin_spectra_analyzer_manual.py : Peak finding, Lorentzian fitting, and batch processing. brillouin_plotter.py : Spectrum previews, heatmaps, and statistical plots. brillouin_cell_selector.py : Cell/background detection and CSV export.","title":"Home"},{"location":"#brillouin-analyzer-documentation","text":"This project provides a lightweight toolkit for parsing, fitting, plotting, and segmenting Brillouin/Raman datasets. Use the docs below as a quick reference for the main modules.","title":"Brillouin Analyzer Documentation"},{"location":"#outline","text":"Parsing : Load Brillouin and Raman datasets, including ZIP handling and lateral step detection. Manual Analysis : Fit peaks in a single spectrum or an entire volume with reproducible window and filtering controls. Plotting : Preview raw spectra, render spatial heatmaps, and summarize cell-level statistics. Cell Selection : Build RGB maps of shifts/FWHM, detect contours, and export per-region metrics.","title":"Outline"},{"location":"#quick-start","text":"1) Parse data with parse_brillouin_set (or parse_raman_set for Raman). 2) Tune peak windows on one pixel using analyze_brillouin_spectrum_manual . 3) Run analyze_brillouin_spectra_manual over the full slice/volume. 4) Visualize with plot_brillouin_heatmap and segment regions with detect_cells . 5) Summarize groups using plot_cell_boxplot or plot_cell_histogram .","title":"Quick Start"},{"location":"#project-structure","text":"brillouin_parser.py : Parsing helpers for Brillouin/Raman datasets. brillouin_spectra_analyzer_manual.py : Peak finding, Lorentzian fitting, and batch processing. brillouin_plotter.py : Spectrum previews, heatmaps, and statistical plots. brillouin_cell_selector.py : Cell/background detection and CSV export.","title":"Project Structure"},{"location":"cell_selection/","text":"Cell Selection Module \u00b6 The brillouin_cell_selector.detect_cells helper turns a peaks map into an RGB heatmap (Stokes shift = red, FWHM = green, Anti-Stokes shift = blue) and extracts per-cell masks. Use it after running the manual analyzer and before aggregating statistics with the plotting functions. What goes in \u00b6 peaks_map : a BrillouinPeaksMap or list of maps from analyze_brillouin_spectra_manual . Lists are aggregated per pixel with pixel_aggregation ( mean or median ). Spatial scaling: set scaling_factor='auto' to reuse the lateral step stored with the peaks map or pass a numeric micron-per-pixel value. Pre-processing controls \u00b6 Filtering: choose filter_type ( median , gaussian , bilateral , wiener , anisotropic_diffusion , total_variation , non_local_means ) with filter_params . Set interpolate_nan=True to fill gaps first. Normalization and ranges: normalize scales channels to [0, 1]; shift_range / fwhm_range clip values (use 'auto' or ('auto', p_low, p_high) for percentile clipping). Aggregation inside each peak: aggregation ( median , mean , or robust ) controls how per-pixel values are extracted. How cells are detected \u00b6 Thresholding: pick threshold_method ( otsu , adaptive , fixed , or manual ). For manual mode, pass manual_regions with polygons or circles. threshold_value is required when fixed . Post-processing: pre_gaussian_blur smooths the grayscale map before thresholding; morph_op applies open/close morphology; contour_smoothing simplifies contour polygons. Contour filters: cell_area limits pixel area, and prominence rejects dim regions. mark_all=True skips detection and treats the whole field as one cell. Outputs \u00b6 cell_shift_maps # dict with keys 'stokes', 'anti-stokes', 'all' -> list of arrays (one per cell) cell_fwhm_maps # dict with keys 'stokes', 'anti-stokes', 'all' -> list of arrays (one per cell) background_shift_maps # same keys, arrays with cells masked out background_fwhm_maps # same keys, arrays with cells masked out If save_csv is a path, a CSV is written for every detected region (plus background when available) with median shift and FWHM. Use fig_path and save_fig=True to store the plotted RGB map with contours and numbering; annotate=True adds per-region statistics to the figure. Example \u00b6 from brillouin_analyzer_src.brillouin_cell_selector import detect_cells cell_shift_maps , cell_fwhm_maps , bg_shift , bg_fwhm = detect_cells ( peaks_map = peaks_maps [ 0 ], title = \"Cell map\" , shift_range = \"auto\" , fwhm_range = \"auto\" , filter_type = \"gaussian\" , filter_params = { \"sigma\" : 1.2 }, threshold_method = \"otsu\" , cell_area = [ 50 , 5000 ], annotate = True , save_fig = True , fig_path = \"exports/cell_map.png\" , save_csv = \"exports/cell_stats\" )","title":"Cell Selection"},{"location":"cell_selection/#cell-selection-module","text":"The brillouin_cell_selector.detect_cells helper turns a peaks map into an RGB heatmap (Stokes shift = red, FWHM = green, Anti-Stokes shift = blue) and extracts per-cell masks. Use it after running the manual analyzer and before aggregating statistics with the plotting functions.","title":"Cell Selection Module"},{"location":"cell_selection/#what-goes-in","text":"peaks_map : a BrillouinPeaksMap or list of maps from analyze_brillouin_spectra_manual . Lists are aggregated per pixel with pixel_aggregation ( mean or median ). Spatial scaling: set scaling_factor='auto' to reuse the lateral step stored with the peaks map or pass a numeric micron-per-pixel value.","title":"What goes in"},{"location":"cell_selection/#pre-processing-controls","text":"Filtering: choose filter_type ( median , gaussian , bilateral , wiener , anisotropic_diffusion , total_variation , non_local_means ) with filter_params . Set interpolate_nan=True to fill gaps first. Normalization and ranges: normalize scales channels to [0, 1]; shift_range / fwhm_range clip values (use 'auto' or ('auto', p_low, p_high) for percentile clipping). Aggregation inside each peak: aggregation ( median , mean , or robust ) controls how per-pixel values are extracted.","title":"Pre-processing controls"},{"location":"cell_selection/#how-cells-are-detected","text":"Thresholding: pick threshold_method ( otsu , adaptive , fixed , or manual ). For manual mode, pass manual_regions with polygons or circles. threshold_value is required when fixed . Post-processing: pre_gaussian_blur smooths the grayscale map before thresholding; morph_op applies open/close morphology; contour_smoothing simplifies contour polygons. Contour filters: cell_area limits pixel area, and prominence rejects dim regions. mark_all=True skips detection and treats the whole field as one cell.","title":"How cells are detected"},{"location":"cell_selection/#outputs","text":"cell_shift_maps # dict with keys 'stokes', 'anti-stokes', 'all' -> list of arrays (one per cell) cell_fwhm_maps # dict with keys 'stokes', 'anti-stokes', 'all' -> list of arrays (one per cell) background_shift_maps # same keys, arrays with cells masked out background_fwhm_maps # same keys, arrays with cells masked out If save_csv is a path, a CSV is written for every detected region (plus background when available) with median shift and FWHM. Use fig_path and save_fig=True to store the plotted RGB map with contours and numbering; annotate=True adds per-region statistics to the figure.","title":"Outputs"},{"location":"cell_selection/#example","text":"from brillouin_analyzer_src.brillouin_cell_selector import detect_cells cell_shift_maps , cell_fwhm_maps , bg_shift , bg_fwhm = detect_cells ( peaks_map = peaks_maps [ 0 ], title = \"Cell map\" , shift_range = \"auto\" , fwhm_range = \"auto\" , filter_type = \"gaussian\" , filter_params = { \"sigma\" : 1.2 }, threshold_method = \"otsu\" , cell_area = [ 50 , 5000 ], annotate = True , save_fig = True , fig_path = \"exports/cell_map.png\" , save_csv = \"exports/cell_stats\" )","title":"Example"},{"location":"manual_analysis/","text":"Manual Analysis Module \u00b6 The brillouin_spectra_analyzer_manual module lets you inspect a single spectrum to tune peak-finding parameters and then run the same settings over an entire 3D dataset. Use it right after parsing data with parse_brillouin_set . Typical Workflow \u00b6 1) Parse spectra into a 3D array. 2) Call analyze_brillouin_spectrum_manual on a single pixel to pick laser/Brillouin windows and fitting options. 3) Reuse those parameters in analyze_brillouin_spectra_manual for a full slice or volume. 4) Visualize and segment the results with the plotting and cell-selection utilities. Single spectrum: analyze_brillouin_spectrum_manual \u00b6 Analyzes one spectrum from the cube (or a provided spectrum_data ) and optionally plots the fit. Key arguments - Coordinates: x_coord , y_coord , z_coord select the pixel; omit to inspect a random spectrum. spectrum_cut_range trims the waveform before processing. - Spectral geometry: free_spectral_range fits the quadratic VIPA calibration. Windows for peaks come from laser_peak_ranges (index windows or exact indices) and brillouin_peak_ranges (pairs of index windows or a tuple (a_GHz, b_GHz) around each laser). - Fitting: set fit_lorentzians>0 to fit Lorentzian peaks inside a \u00b1window (GHz). Control bounds via fwhm_bounds_GHz and center_slack_GHz . match_brilouin_parameters=True locks all left/right Brillouin peaks to shared width/shift. - Filtering and weighting: provide filter_settings (Savgol, wavelet, Fourier, PCA, or custom callables) to denoise before peak finding; enable baseline_spectra or poisson_weighting if you need them. - Debugging and plots: debug_plot overlays search windows, plot_PCA / pca_* help to locate laser peaks, make_plot controls size, and save_plot writes the figure. Outputs Returns a dictionary containing: - df : per-peak rows with type, shift, FWHM, center/amplitude, and fit RMSE. - spectrum , rescaled_x_axis , and the detected laser_peaks_indices / brillouin_peaks_indices . - fit_params (a, b, c) from the VIPA calibration plus lists of per-peak shifts, FWHMs, amplitudes, and centers. - Flags showing which options were enabled (baseline, weighting, matching, etc.). Example: from brillouin_analyzer_src import * % load_ext autoreload % autoreload 2 res = def analyze_brillouin_spectrum_manual ( brillouin_spectra , x_coord = None , y_coord = None , z_coord = None , free_spectral_range = 29.98 , laser_peak_ranges = [ 626 , 986 , 1269 , 1510 ], brillouin_peak_ranges = ( 6 , 11 ), spectrum_cut_range = ( 350 , 1600 ), make_plot = ( 12 , 8 ), debug_plot = False , # Lorentzian half-window in GHz (0 -> disable fitting) fit_lorentzians = 1.5 , # Optional filter pipeline configuration filter_settings = [{ 'type' : 'savgol' , 'params' : ( 15 , 6 )}, { 'type' : 'wavelet' , 'wavelet' : 'db6' , 'level' : 5 }, { 'type' : 'fft' , 'params' : ( 20 , 100 )}], save_plot = False , # Optional constraints for Lorentzian fitting (GHz) fwhm_bounds_GHz = ( 0.8 , 4.0 ), # (min_fwhm, max_fwhm) or None center_slack_GHz = 0.5 , # \u00b1 slack around nominal center; if None, window-bound spectrum_data = None , baseline_spectra = False , poisson_weighting = False , match_brilouin_parameters = True , ignore_brilouin_peaks = False , plot_PCA = False , pca_n_components = 2 , pca_params = { 'svd_solver' : 'full' , 'whiten' : True , 'tol' : 0.0 , 'iterated_power' : 5 , 'random_state' : None , 'copy' : True , }, pca_peak_finding_params = { 'height' : 0.02 , # Minimum height of peaks 'distance' : 100 , # Minimum horizontal distance between peaks 'prominence' : 0 , # Minimum prominence of peaks 'width' : 2 , # Minimum width of peaks } ) Batch mode: analyze_brillouin_spectra_manual \u00b6 Runs the same analysis across a z-slice or the full volume. Highlights - z_coord=None processes all slices; set an int to restrict to one slice. - Parallel execution via max_workers and parallel_backend ( auto , thread , process ). Use max_workers=1 for reproducible sequential runs. - laser_refit=True performs a laser-only pre-pass to lock Rayleigh peak positions before full fitting. refit keeps a global VIPA refit (ignored when laser_refit=True ). - Pass through the same peak windows, fitting, filtering, and matching options you validated on a single spectrum. keep_waveforms=False drops raw spectra from the results to save memory. Returns A BrillouinPeaksMap (or list of maps if z_coord=None ) keyed by (x, y, z) with the per-pixel result dictionaries. The lateral step is stored internally for plotting and cell selection. Example: from brillouin_analyzer_src.brillouin_spectra_analyzer_manual import analyze_brillouin_spectra_manual peaks_maps = analyze_brillouin_spectra_manual ( data , z_coord = None , free_spectral_range = 29.98 , laser_peak_ranges = [ 626 , 986 , 1269 , 1510 ], brillouin_peak_ranges = ( 6 , 11 ), spectrum_cut_range = ( 350 , 1600 ), fit_lorentzians = 1.5 , filter_settings = [{ 'type' : 'savgol' , 'params' : ( 15 , 6 )}, { 'type' : 'wavelet' , 'wavelet' : 'db6' , 'level' : 5 }, { 'type' : 'fft' , 'params' : ( 20 , 100 )}], refit = False , laser_refit = True , match_brilouin_parameters = True , max_workers = 8 , parallel_backend = 'auto' keep_waveforms = False , baseline_spectra = False , poisson_weighting = False , plot_PCA = False , pca_n_components = 2 , pca_params = { 'svd_solver' : 'full' , 'whiten' : True , 'tol' : 0.0 , 'iterated_power' : 5 , 'random_state' : None , 'copy' : True , }, pca_peak_finding_params = { 'height' : 0.02 , # Minimum height of peaks 'distance' : 100 , # Minimum horizontal distance between peaks 'prominence' : 0 , # Minimum prominence of peaks 'width' : 2 , # Minimum width of peaks } )","title":"Manual Analysis"},{"location":"manual_analysis/#manual-analysis-module","text":"The brillouin_spectra_analyzer_manual module lets you inspect a single spectrum to tune peak-finding parameters and then run the same settings over an entire 3D dataset. Use it right after parsing data with parse_brillouin_set .","title":"Manual Analysis Module"},{"location":"manual_analysis/#typical-workflow","text":"1) Parse spectra into a 3D array. 2) Call analyze_brillouin_spectrum_manual on a single pixel to pick laser/Brillouin windows and fitting options. 3) Reuse those parameters in analyze_brillouin_spectra_manual for a full slice or volume. 4) Visualize and segment the results with the plotting and cell-selection utilities.","title":"Typical Workflow"},{"location":"manual_analysis/#single-spectrum-analyze_brillouin_spectrum_manual","text":"Analyzes one spectrum from the cube (or a provided spectrum_data ) and optionally plots the fit. Key arguments - Coordinates: x_coord , y_coord , z_coord select the pixel; omit to inspect a random spectrum. spectrum_cut_range trims the waveform before processing. - Spectral geometry: free_spectral_range fits the quadratic VIPA calibration. Windows for peaks come from laser_peak_ranges (index windows or exact indices) and brillouin_peak_ranges (pairs of index windows or a tuple (a_GHz, b_GHz) around each laser). - Fitting: set fit_lorentzians>0 to fit Lorentzian peaks inside a \u00b1window (GHz). Control bounds via fwhm_bounds_GHz and center_slack_GHz . match_brilouin_parameters=True locks all left/right Brillouin peaks to shared width/shift. - Filtering and weighting: provide filter_settings (Savgol, wavelet, Fourier, PCA, or custom callables) to denoise before peak finding; enable baseline_spectra or poisson_weighting if you need them. - Debugging and plots: debug_plot overlays search windows, plot_PCA / pca_* help to locate laser peaks, make_plot controls size, and save_plot writes the figure. Outputs Returns a dictionary containing: - df : per-peak rows with type, shift, FWHM, center/amplitude, and fit RMSE. - spectrum , rescaled_x_axis , and the detected laser_peaks_indices / brillouin_peaks_indices . - fit_params (a, b, c) from the VIPA calibration plus lists of per-peak shifts, FWHMs, amplitudes, and centers. - Flags showing which options were enabled (baseline, weighting, matching, etc.). Example: from brillouin_analyzer_src import * % load_ext autoreload % autoreload 2 res = def analyze_brillouin_spectrum_manual ( brillouin_spectra , x_coord = None , y_coord = None , z_coord = None , free_spectral_range = 29.98 , laser_peak_ranges = [ 626 , 986 , 1269 , 1510 ], brillouin_peak_ranges = ( 6 , 11 ), spectrum_cut_range = ( 350 , 1600 ), make_plot = ( 12 , 8 ), debug_plot = False , # Lorentzian half-window in GHz (0 -> disable fitting) fit_lorentzians = 1.5 , # Optional filter pipeline configuration filter_settings = [{ 'type' : 'savgol' , 'params' : ( 15 , 6 )}, { 'type' : 'wavelet' , 'wavelet' : 'db6' , 'level' : 5 }, { 'type' : 'fft' , 'params' : ( 20 , 100 )}], save_plot = False , # Optional constraints for Lorentzian fitting (GHz) fwhm_bounds_GHz = ( 0.8 , 4.0 ), # (min_fwhm, max_fwhm) or None center_slack_GHz = 0.5 , # \u00b1 slack around nominal center; if None, window-bound spectrum_data = None , baseline_spectra = False , poisson_weighting = False , match_brilouin_parameters = True , ignore_brilouin_peaks = False , plot_PCA = False , pca_n_components = 2 , pca_params = { 'svd_solver' : 'full' , 'whiten' : True , 'tol' : 0.0 , 'iterated_power' : 5 , 'random_state' : None , 'copy' : True , }, pca_peak_finding_params = { 'height' : 0.02 , # Minimum height of peaks 'distance' : 100 , # Minimum horizontal distance between peaks 'prominence' : 0 , # Minimum prominence of peaks 'width' : 2 , # Minimum width of peaks } )","title":"Single spectrum: analyze_brillouin_spectrum_manual"},{"location":"manual_analysis/#batch-mode-analyze_brillouin_spectra_manual","text":"Runs the same analysis across a z-slice or the full volume. Highlights - z_coord=None processes all slices; set an int to restrict to one slice. - Parallel execution via max_workers and parallel_backend ( auto , thread , process ). Use max_workers=1 for reproducible sequential runs. - laser_refit=True performs a laser-only pre-pass to lock Rayleigh peak positions before full fitting. refit keeps a global VIPA refit (ignored when laser_refit=True ). - Pass through the same peak windows, fitting, filtering, and matching options you validated on a single spectrum. keep_waveforms=False drops raw spectra from the results to save memory. Returns A BrillouinPeaksMap (or list of maps if z_coord=None ) keyed by (x, y, z) with the per-pixel result dictionaries. The lateral step is stored internally for plotting and cell selection. Example: from brillouin_analyzer_src.brillouin_spectra_analyzer_manual import analyze_brillouin_spectra_manual peaks_maps = analyze_brillouin_spectra_manual ( data , z_coord = None , free_spectral_range = 29.98 , laser_peak_ranges = [ 626 , 986 , 1269 , 1510 ], brillouin_peak_ranges = ( 6 , 11 ), spectrum_cut_range = ( 350 , 1600 ), fit_lorentzians = 1.5 , filter_settings = [{ 'type' : 'savgol' , 'params' : ( 15 , 6 )}, { 'type' : 'wavelet' , 'wavelet' : 'db6' , 'level' : 5 }, { 'type' : 'fft' , 'params' : ( 20 , 100 )}], refit = False , laser_refit = True , match_brilouin_parameters = True , max_workers = 8 , parallel_backend = 'auto' keep_waveforms = False , baseline_spectra = False , poisson_weighting = False , plot_PCA = False , pca_n_components = 2 , pca_params = { 'svd_solver' : 'full' , 'whiten' : True , 'tol' : 0.0 , 'iterated_power' : 5 , 'random_state' : None , 'copy' : True , }, pca_peak_finding_params = { 'height' : 0.02 , # Minimum height of peaks 'distance' : 100 , # Minimum horizontal distance between peaks 'prominence' : 0 , # Minimum prominence of peaks 'width' : 2 , # Minimum width of peaks } )","title":"Batch mode: analyze_brillouin_spectra_manual"},{"location":"parsing/","text":"Parsing Module \u00b6 The brillouin_parser module provides functionality to load and parse Brillouin and Raman spectra data from directories or ZIP archives. Functions \u00b6 parse_brillouin_set \u00b6 def parse_brillouin_set ( directory_path , file_label ): ... Parses a set of Brillouin spectra files. Arguments: directory_path (str): Path to the directory or ZIP file containing the data. file_label (str): The label used to identify the files (e.g., the prefix of the filenames). Returns: numpy.ndarray : A 3D array of object type, where each element contains the spectral data (intensity) for a specific (x, y, z) coordinate. The indices of the array correspond to the spatial coordinates. Description: This function locates the dataset (extracting it from a ZIP file if necessary), finds the lateral step size, and reads .asc files matching the pattern {file_label}B*_Z...Y...X...asc . It constructs a 3D array representing the spatial distribution of the spectra. It also registers the lateral step metadata using data_registry.register_lateral_step . parse_raman_set \u00b6 def parse_raman_set ( directory_path , file_label ): ... Parses a set of Raman spectra files. Arguments: directory_path (str): Path to the directory or ZIP file containing the data. file_label (str): The label used to identify the files. Returns: dict or None : A dictionary where keys are (x, y, z) tuples and values are the spectral data (intensity), or None if no files are found. (Note: The current implementation returns a dictionary, unlike parse_brillouin_set which returns a 3D array. Check implementation details if this is intended behavior ). Description: Similar to parse_brillouin_set , this function reads .asc files matching the pattern {file_label}R*_Z...Y...X...asc . File Naming Convention \u00b6 The parser expects files to follow a specific naming convention to extract spatial coordinates: Brillouin files: {file_label}B*_Z{z}Y{y}X{x}.asc Raman files: {file_label}R*_Z{z}Y{y}X{x}.asc Where {x} , {y} , and {z} are integer coordinates. Lateral Step Detection \u00b6 The parser attempts to automatically detect the \"Lateral step\" size from text files in the directory. It looks for files named: 1. {file_label}.txt 2. {sanitized_label}.txt (spaces replaced by underscores) 3. file_label.txt It searches for a line matching the pattern Lateral step : {value} . ZIP Archive Support \u00b6 The functions support reading data directly from ZIP archives. If directory_path points to a .zip file, the parser will: 1. Extract the archive to a temporary directory. 2. Search for a folder matching file_label or its sanitized version. 3. If not found, check if there is a single top-level directory. 4. If not found, search for a directory containing files starting with file_label . 5. Use the found directory as the source for parsing.","title":"Parsing"},{"location":"parsing/#parsing-module","text":"The brillouin_parser module provides functionality to load and parse Brillouin and Raman spectra data from directories or ZIP archives.","title":"Parsing Module"},{"location":"parsing/#functions","text":"","title":"Functions"},{"location":"parsing/#parse_brillouin_set","text":"def parse_brillouin_set ( directory_path , file_label ): ... Parses a set of Brillouin spectra files. Arguments: directory_path (str): Path to the directory or ZIP file containing the data. file_label (str): The label used to identify the files (e.g., the prefix of the filenames). Returns: numpy.ndarray : A 3D array of object type, where each element contains the spectral data (intensity) for a specific (x, y, z) coordinate. The indices of the array correspond to the spatial coordinates. Description: This function locates the dataset (extracting it from a ZIP file if necessary), finds the lateral step size, and reads .asc files matching the pattern {file_label}B*_Z...Y...X...asc . It constructs a 3D array representing the spatial distribution of the spectra. It also registers the lateral step metadata using data_registry.register_lateral_step .","title":"parse_brillouin_set"},{"location":"parsing/#parse_raman_set","text":"def parse_raman_set ( directory_path , file_label ): ... Parses a set of Raman spectra files. Arguments: directory_path (str): Path to the directory or ZIP file containing the data. file_label (str): The label used to identify the files. Returns: dict or None : A dictionary where keys are (x, y, z) tuples and values are the spectral data (intensity), or None if no files are found. (Note: The current implementation returns a dictionary, unlike parse_brillouin_set which returns a 3D array. Check implementation details if this is intended behavior ). Description: Similar to parse_brillouin_set , this function reads .asc files matching the pattern {file_label}R*_Z...Y...X...asc .","title":"parse_raman_set"},{"location":"parsing/#file-naming-convention","text":"The parser expects files to follow a specific naming convention to extract spatial coordinates: Brillouin files: {file_label}B*_Z{z}Y{y}X{x}.asc Raman files: {file_label}R*_Z{z}Y{y}X{x}.asc Where {x} , {y} , and {z} are integer coordinates.","title":"File Naming Convention"},{"location":"parsing/#lateral-step-detection","text":"The parser attempts to automatically detect the \"Lateral step\" size from text files in the directory. It looks for files named: 1. {file_label}.txt 2. {sanitized_label}.txt (spaces replaced by underscores) 3. file_label.txt It searches for a line matching the pattern Lateral step : {value} .","title":"Lateral Step Detection"},{"location":"parsing/#zip-archive-support","text":"The functions support reading data directly from ZIP archives. If directory_path points to a .zip file, the parser will: 1. Extract the archive to a temporary directory. 2. Search for a folder matching file_label or its sanitized version. 3. If not found, check if there is a single top-level directory. 4. If not found, search for a directory containing files starting with file_label . 5. Use the found directory as the source for parsing.","title":"ZIP Archive Support"},{"location":"plotting/","text":"Plotting Module \u00b6 The brillouin_plotter utilities turn parsed/analysed data into figures for validation and publication. They accept the outputs of parse_brillouin_set , analyze_brillouin_spectrum_manual , and analyze_brillouin_spectra_manual , plus the cell masks produced by detect_cells . Spectra preview: plot_raw_spectrum \u00b6 Plots a single raw spectrum and marks peaks found by scipy.signal.find_peaks . - spectrum_range trims the waveform before plotting; negative values are clamped to zero automatically. - height , distance , and prominence are passed to find_peaks . - mark_ranges shades useful index ranges (for example, candidate laser windows). from brillouin_analyzer_src.brillouin_plotter import plot_raw_spectrum plot_raw_spectrum ( spectra , x_coord = 3 , y_coord = 4 , z_coord = 0 , mark_ranges = [( 200 , 260 )]) Spatial heatmaps: plot_brillouin_heatmap \u00b6 Builds a heatmap from a peaks map (or a list of maps) returned by the manual analyzer. - Pick the value to plot with data_type ( Shift or FWHM ) and peak_type ( Brillouin , Brillouin Left , Brillouin Right , Laser , etc.). match_type='contains' broadens label matching. - Aggregation: aggregation applies inside each pixel (median/mean/robust); pixel_aggregation combines multiple maps (mean/median). - Cleaning: interpolate_nan , optional filters ( median , gaussian , bilateral , wiener , anisotropic_diffusion , total_variation , non_local_means ), and colorbar_range control visibility. - Axes: set scale='auto' to reuse the lateral step stored in the peaks map or pass a numeric scale. matrix_save_path writes the plotted matrix to a tab-separated file. from brillouin_analyzer_src.brillouin_plotter import plot_brillouin_heatmap plot_brillouin_heatmap ( peaks_map = peaks_maps [ 0 ], title = \"Median Brillouin shift\" , data_type = \"Shift\" , peak_type = \"Brillouin\" , pixel_aggregation = \"median\" , colorbar_range = \"auto\" , scale = \"auto\" ) Cell-level statistics \u00b6 Use the outputs of detect_cells (cell shift/FWHM maps plus background) to summarize samples. Box/violin/error plots: plot_cell_boxplot \u00b6 Inputs: samples_data_list is a list where each element is the 4-tuple returned by detect_cells (shift maps, FWHM maps, background shift, background FWHM). Pass multiple samples to compare cohorts. Pick metric with data_type ( shift / fwhm ) and shift_type ( stokes , anti-stokes , all ). Presentation controls: plot_type ( box , violin , errorbar , or scatter ), aggregate_per_cell ( pixel , cell , or both ), show_data_points , and plot_background . Statistics: enable plot_p_values with comparisons=[(0,1), ...] , choose test_type ( mannwhitney , ttest , or both ), and format with p_value_format ( numeric or stars ). from brillouin_analyzer_src.brillouin_plotter import plot_cell_boxplot plot_cell_boxplot ( samples_data_list = [ cells_treated , cells_control ], labels = [ \"Treated\" , \"Control\" ], data_type = \"shift\" , shift_type = \"all\" , plot_type = \"box\" , plot_p_values = True , comparisons = [( 0 , 1 )] ) Histograms: plot_cell_histogram \u00b6 Creates a histogram of per-cell or background values, fits a Gaussian, and can export the underlying arrays. - data_list accepts the same 4-tuples from detect_cells ; set cell_or_background accordingly. - Limit with cell_numbers , clip with value_range , and choose data_type / shift_type . - Set save_values=True (optionally with values_output_dir and values_filename_prefix ) to write both shift and FWHM arrays to disk. from brillouin_analyzer_src.brillouin_plotter import plot_cell_histogram plot_cell_histogram ( [ cells_treated ], title = \"Shift distribution\" , cell_or_background = \"cell\" , data_type = \"shift\" , shift_type = \"all\" , bin_number = 20 , save_values = True , values_output_dir = \"exports\" )","title":"Plotting"},{"location":"plotting/#plotting-module","text":"The brillouin_plotter utilities turn parsed/analysed data into figures for validation and publication. They accept the outputs of parse_brillouin_set , analyze_brillouin_spectrum_manual , and analyze_brillouin_spectra_manual , plus the cell masks produced by detect_cells .","title":"Plotting Module"},{"location":"plotting/#spectra-preview-plot_raw_spectrum","text":"Plots a single raw spectrum and marks peaks found by scipy.signal.find_peaks . - spectrum_range trims the waveform before plotting; negative values are clamped to zero automatically. - height , distance , and prominence are passed to find_peaks . - mark_ranges shades useful index ranges (for example, candidate laser windows). from brillouin_analyzer_src.brillouin_plotter import plot_raw_spectrum plot_raw_spectrum ( spectra , x_coord = 3 , y_coord = 4 , z_coord = 0 , mark_ranges = [( 200 , 260 )])","title":"Spectra preview: plot_raw_spectrum"},{"location":"plotting/#spatial-heatmaps-plot_brillouin_heatmap","text":"Builds a heatmap from a peaks map (or a list of maps) returned by the manual analyzer. - Pick the value to plot with data_type ( Shift or FWHM ) and peak_type ( Brillouin , Brillouin Left , Brillouin Right , Laser , etc.). match_type='contains' broadens label matching. - Aggregation: aggregation applies inside each pixel (median/mean/robust); pixel_aggregation combines multiple maps (mean/median). - Cleaning: interpolate_nan , optional filters ( median , gaussian , bilateral , wiener , anisotropic_diffusion , total_variation , non_local_means ), and colorbar_range control visibility. - Axes: set scale='auto' to reuse the lateral step stored in the peaks map or pass a numeric scale. matrix_save_path writes the plotted matrix to a tab-separated file. from brillouin_analyzer_src.brillouin_plotter import plot_brillouin_heatmap plot_brillouin_heatmap ( peaks_map = peaks_maps [ 0 ], title = \"Median Brillouin shift\" , data_type = \"Shift\" , peak_type = \"Brillouin\" , pixel_aggregation = \"median\" , colorbar_range = \"auto\" , scale = \"auto\" )","title":"Spatial heatmaps: plot_brillouin_heatmap"},{"location":"plotting/#cell-level-statistics","text":"Use the outputs of detect_cells (cell shift/FWHM maps plus background) to summarize samples.","title":"Cell-level statistics"},{"location":"plotting/#boxviolinerror-plots-plot_cell_boxplot","text":"Inputs: samples_data_list is a list where each element is the 4-tuple returned by detect_cells (shift maps, FWHM maps, background shift, background FWHM). Pass multiple samples to compare cohorts. Pick metric with data_type ( shift / fwhm ) and shift_type ( stokes , anti-stokes , all ). Presentation controls: plot_type ( box , violin , errorbar , or scatter ), aggregate_per_cell ( pixel , cell , or both ), show_data_points , and plot_background . Statistics: enable plot_p_values with comparisons=[(0,1), ...] , choose test_type ( mannwhitney , ttest , or both ), and format with p_value_format ( numeric or stars ). from brillouin_analyzer_src.brillouin_plotter import plot_cell_boxplot plot_cell_boxplot ( samples_data_list = [ cells_treated , cells_control ], labels = [ \"Treated\" , \"Control\" ], data_type = \"shift\" , shift_type = \"all\" , plot_type = \"box\" , plot_p_values = True , comparisons = [( 0 , 1 )] )","title":"Box/violin/error plots: plot_cell_boxplot"},{"location":"plotting/#histograms-plot_cell_histogram","text":"Creates a histogram of per-cell or background values, fits a Gaussian, and can export the underlying arrays. - data_list accepts the same 4-tuples from detect_cells ; set cell_or_background accordingly. - Limit with cell_numbers , clip with value_range , and choose data_type / shift_type . - Set save_values=True (optionally with values_output_dir and values_filename_prefix ) to write both shift and FWHM arrays to disk. from brillouin_analyzer_src.brillouin_plotter import plot_cell_histogram plot_cell_histogram ( [ cells_treated ], title = \"Shift distribution\" , cell_or_background = \"cell\" , data_type = \"shift\" , shift_type = \"all\" , bin_number = 20 , save_values = True , values_output_dir = \"exports\" )","title":"Histograms: plot_cell_histogram"}]}